{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"C:/ngmi/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/ngmi/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar _curve = null;\n\nfunction getCurve() {\n  if (!_curve) {\n    _curve = new EC(\"secp256k1\");\n  }\n\n  return _curve;\n}\n\nexport var SigningKey = /*#__PURE__*/function () {\n  function SigningKey(privateKey) {\n    _classCallCheck(this, SigningKey);\n\n    defineReadOnly(this, \"curve\", \"secp256k1\");\n    defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n    var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n    defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n    defineReadOnly(this, \"_isSigningKey\", true);\n  }\n\n  _createClass(SigningKey, [{\n    key: \"_addPoint\",\n    value: function _addPoint(other) {\n      var p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n      var p1 = getCurve().keyFromPublic(arrayify(other));\n      return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n  }, {\n    key: \"signDigest\",\n    value: function signDigest(digest) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var digestBytes = arrayify(digest);\n\n      if (digestBytes.length !== 32) {\n        logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n      }\n\n      var signature = keyPair.sign(digestBytes, {\n        canonical: true\n      });\n      return splitSignature({\n        recoveryParam: signature.recoveryParam,\n        r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n        s: hexZeroPad(\"0x\" + signature.s.toString(16), 32)\n      });\n    }\n  }, {\n    key: \"computeSharedSecret\",\n    value: function computeSharedSecret(otherKey) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n      return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n  }], [{\n    key: \"isSigningKey\",\n    value: function isSigningKey(value) {\n      return !!(value && value._isSigningKey);\n    }\n  }]);\n\n  return SigningKey;\n}();\nexport function recoverPublicKey(digest, signature) {\n  var sig = splitSignature(signature);\n  var rs = {\n    r: arrayify(sig.r),\n    s: arrayify(sig.s)\n  };\n  return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n  var bytes = arrayify(key);\n\n  if (bytes.length === 32) {\n    var signingKey = new SigningKey(bytes);\n\n    if (compressed) {\n      return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n    }\n\n    return signingKey.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return hexlify(bytes);\n    }\n\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return hexlify(bytes);\n    }\n\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n  }\n\n  return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nimport { EC } from \"./elliptic\";\r\nimport { arrayify, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nlet _curve = null;\r\nfunction getCurve() {\r\n    if (!_curve) {\r\n        _curve = new EC(\"secp256k1\");\r\n    }\r\n    return _curve;\r\n}\r\nexport class SigningKey {\r\n    constructor(privateKey) {\r\n        defineReadOnly(this, \"curve\", \"secp256k1\");\r\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\r\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\r\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\r\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\r\n        defineReadOnly(this, \"_isSigningKey\", true);\r\n    }\r\n    _addPoint(other) {\r\n        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\r\n        const p1 = getCurve().keyFromPublic(arrayify(other));\r\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\r\n    }\r\n    signDigest(digest) {\r\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\r\n        const digestBytes = arrayify(digest);\r\n        if (digestBytes.length !== 32) {\r\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\r\n        }\r\n        const signature = keyPair.sign(digestBytes, { canonical: true });\r\n        return splitSignature({\r\n            recoveryParam: signature.recoveryParam,\r\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\r\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\r\n        });\r\n    }\r\n    computeSharedSecret(otherKey) {\r\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\r\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\r\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\r\n    }\r\n    static isSigningKey(value) {\r\n        return !!(value && value._isSigningKey);\r\n    }\r\n}\r\nexport function recoverPublicKey(digest, signature) {\r\n    const sig = splitSignature(signature);\r\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\r\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\r\n}\r\nexport function computePublicKey(key, compressed) {\r\n    const bytes = arrayify(key);\r\n    if (bytes.length === 32) {\r\n        const signingKey = new SigningKey(bytes);\r\n        if (compressed) {\r\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\r\n        }\r\n        return signingKey.publicKey;\r\n    }\r\n    else if (bytes.length === 33) {\r\n        if (compressed) {\r\n            return hexlify(bytes);\r\n        }\r\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\r\n    }\r\n    else if (bytes.length === 65) {\r\n        if (!compressed) {\r\n            return hexlify(bytes);\r\n        }\r\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\r\n    }\r\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}