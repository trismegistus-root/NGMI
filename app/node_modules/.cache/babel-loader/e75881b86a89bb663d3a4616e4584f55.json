{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version); ///////////////////////////////\n\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n\n  return getAddress(value);\n}\n\nfunction handleNumber(value) {\n  if (value === \"0x\") {\n    return Zero;\n  }\n\n  return BigNumber.from(value);\n}\n\nconst transactionFields = [{\n  name: \"nonce\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasPrice\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasLimit\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"to\",\n  length: 20\n}, {\n  name: \"value\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"data\"\n}];\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true\n};\nexport function computeAddress(key) {\n  const publicKey = computePublicKey(key);\n  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nexport function serialize(transaction, signature) {\n  checkProperties(transaction, allowedTransactionKeys);\n  const raw = [];\n  transactionFields.forEach(function (fieldInfo) {\n    let value = transaction[fieldInfo.name] || [];\n    const options = {};\n\n    if (fieldInfo.numeric) {\n      options.hexPad = \"left\";\n    }\n\n    value = arrayify(hexlify(value, options)); // Fixed-width field\n\n    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n      logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n    } // Variable-width (with a maximum)\n\n\n    if (fieldInfo.maxLength) {\n      value = stripZeros(value);\n\n      if (value.length > fieldInfo.maxLength) {\n        logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n      }\n    }\n\n    raw.push(hexlify(value));\n  });\n  let chainId = 0;\n\n  if (transaction.chainId != null) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = transaction.chainId;\n\n    if (typeof chainId !== \"number\") {\n      logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n    }\n  } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n    // No chainId provided, but the signature is signing with EIP-155; derive chainId\n    chainId = Math.floor((signature.v - 35) / 2);\n  } // We have an EIP-155 transaction (chainId was specified and non-zero)\n\n\n  if (chainId !== 0) {\n    raw.push(hexlify(chainId)); // @TODO: hexValue?\n\n    raw.push(\"0x\");\n    raw.push(\"0x\");\n  } // Requesting an unsigned transation\n\n\n  if (!signature) {\n    return RLP.encode(raw);\n  } // The splitSignature will ensure the transaction has a recoveryParam in the\n  // case that the signTransaction function only adds a v.\n\n\n  const sig = splitSignature(signature); // We pushed a chainId and null r, s on for hashing only; remove those\n\n  let v = 27 + sig.recoveryParam;\n\n  if (chainId !== 0) {\n    raw.pop();\n    raw.pop();\n    raw.pop();\n    v += chainId * 2 + 8; // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\n    if (sig.v > 28 && sig.v !== v) {\n      logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n  } else if (sig.v !== v) {\n    logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n  }\n\n  raw.push(hexlify(v));\n  raw.push(stripZeros(arrayify(sig.r)));\n  raw.push(stripZeros(arrayify(sig.s)));\n  return RLP.encode(raw);\n}\nexport function parse(rawTransaction) {\n  const transaction = RLP.decode(rawTransaction);\n\n  if (transaction.length !== 9 && transaction.length !== 6) {\n    logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n  }\n\n  const tx = {\n    nonce: handleNumber(transaction[0]).toNumber(),\n    gasPrice: handleNumber(transaction[1]),\n    gasLimit: handleNumber(transaction[2]),\n    to: handleAddress(transaction[3]),\n    value: handleNumber(transaction[4]),\n    data: transaction[5],\n    chainId: 0\n  }; // Legacy unsigned transaction\n\n  if (transaction.length === 6) {\n    return tx;\n  }\n\n  try {\n    tx.v = BigNumber.from(transaction[6]).toNumber();\n  } catch (error) {\n    console.log(error);\n    return tx;\n  }\n\n  tx.r = hexZeroPad(transaction[7], 32);\n  tx.s = hexZeroPad(transaction[8], 32);\n\n  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.v;\n    tx.v = 0;\n  } else {\n    // Signed Tranasaction\n    tx.chainId = Math.floor((tx.v - 35) / 2);\n\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n\n    let recoveryParam = tx.v - 27;\n    const raw = transaction.slice(0, 6);\n\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push(\"0x\");\n      raw.push(\"0x\");\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n\n    const digest = keccak256(RLP.encode(raw));\n\n    try {\n      tx.from = recoverAddress(digest, {\n        r: hexlify(tx.r),\n        s: hexlify(tx.s),\n        recoveryParam: recoveryParam\n      });\n    } catch (error) {\n      console.log(error);\n    }\n\n    tx.hash = keccak256(rawTransaction);\n  }\n\n  return tx;\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"AAAA;;AAEA,SAAS,UAAT,QAA2B,wBAA3B;AACA,SAAS,SAAT,QAAwC,0BAAxC;AACA,SAAS,QAAT,EAA2C,YAA3C,EAAyD,OAAzD,EAAkE,UAAlE,EAA8E,WAA9E,EAA0G,cAA1G,EAA0H,UAA1H,QAA6I,sBAA7I;AACA,SAAS,IAAT,QAAqB,0BAArB;AACA,SAAS,SAAT,QAA0B,0BAA1B;AACA,SAAS,eAAT,QAAgC,2BAAhC;AACA,OAAO,KAAK,GAAZ,MAAqB,oBAArB;AACA,SAAS,gBAAT,EAA2B,gBAA3B,QAAmD,4BAAnD;AAEA,SAAS,MAAT,QAAuB,uBAAvB;AACA,SAAS,OAAT,QAAwB,YAAxB;AACA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf,C,CAoCA;;AAEA,SAAS,aAAT,CAAuB,KAAvB,EAAoC;AAChC,MAAI,KAAK,KAAK,IAAd,EAAoB;AAAE,WAAO,IAAP;AAAc;;AACpC,SAAO,UAAU,CAAC,KAAD,CAAjB;AACH;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAAmC;AAC/B,MAAI,KAAK,KAAK,IAAd,EAAoB;AAAE,WAAO,IAAP;AAAc;;AACpC,SAAO,SAAS,CAAC,IAAV,CAAe,KAAf,CAAP;AACH;;AAED,MAAM,iBAAiB,GAAG,CACtB;AAAE,EAAA,IAAI,EAAE,OAAR;AAAoB,EAAA,SAAS,EAAE,EAA/B;AAAmC,EAAA,OAAO,EAAE;AAA5C,CADsB,EAEtB;AAAE,EAAA,IAAI,EAAE,UAAR;AAAoB,EAAA,SAAS,EAAE,EAA/B;AAAmC,EAAA,OAAO,EAAE;AAA5C,CAFsB,EAGtB;AAAE,EAAA,IAAI,EAAE,UAAR;AAAoB,EAAA,SAAS,EAAE,EAA/B;AAAmC,EAAA,OAAO,EAAE;AAA5C,CAHsB,EAItB;AAAE,EAAA,IAAI,EAAE,IAAR;AAAuB,EAAA,MAAM,EAAE;AAA/B,CAJsB,EAKtB;AAAE,EAAA,IAAI,EAAE,OAAR;AAAoB,EAAA,SAAS,EAAE,EAA/B;AAAmC,EAAA,OAAO,EAAE;AAA5C,CALsB,EAMtB;AAAE,EAAA,IAAI,EAAE;AAAR,CANsB,CAA1B;AASA,MAAM,sBAAsB,GAAiC;AACzD,EAAA,OAAO,EAAE,IADgD;AAC1C,EAAA,IAAI,EAAE,IADoC;AAC9B,EAAA,QAAQ,EAAE,IADoB;AACd,EAAA,QAAQ,EAAC,IADK;AACC,EAAA,KAAK,EAAE,IADR;AACc,EAAA,EAAE,EAAE,IADlB;AACwB,EAAA,KAAK,EAAE;AAD/B,CAA7D;AAIA,OAAM,SAAU,cAAV,CAAyB,GAAzB,EAAgD;AAClD,QAAM,SAAS,GAAG,gBAAgB,CAAC,GAAD,CAAlC;AACA,SAAO,UAAU,CAAC,YAAY,CAAC,SAAS,CAAC,YAAY,CAAC,SAAD,EAAY,CAAZ,CAAb,CAAV,EAAwC,EAAxC,CAAb,CAAjB;AACH;AAED,OAAM,SAAU,cAAV,CAAyB,MAAzB,EAA4C,SAA5C,EAAoE;AACtE,SAAO,cAAc,CAAC,gBAAgB,CAAC,QAAQ,CAAC,MAAD,CAAT,EAAmB,SAAnB,CAAjB,CAArB;AACH;AAGD,OAAM,SAAU,SAAV,CAAoB,WAApB,EAAsD,SAAtD,EAA+E;AACjF,EAAA,eAAe,CAAC,WAAD,EAAc,sBAAd,CAAf;AAEA,QAAM,GAAG,GAA+B,EAAxC;AAEA,EAAA,iBAAiB,CAAC,OAAlB,CAA0B,UAAS,SAAT,EAAkB;AACxC,QAAI,KAAK,GAAS,WAAY,CAAC,SAAS,CAAC,IAAX,CAAZ,IAAiC,EAAnD;AACA,UAAM,OAAO,GAAgB,EAA7B;;AACA,QAAI,SAAS,CAAC,OAAd,EAAuB;AAAE,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAjB;AAA0B;;AACnD,IAAA,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAD,EAAQ,OAAR,CAAR,CAAhB,CAJwC,CAMxC;;AACA,QAAI,SAAS,CAAC,MAAV,IAAoB,KAAK,CAAC,MAAN,KAAiB,SAAS,CAAC,MAA/C,IAAyD,KAAK,CAAC,MAAN,GAAe,CAA5E,EAA+E;AAC3E,MAAA,MAAM,CAAC,kBAAP,CAA0B,wBAAwB,SAAS,CAAC,IAA5D,EAAmE,iBAAiB,SAAS,CAAC,IAA9F,EAAqG,KAArG;AACH,KATuC,CAWxC;;;AACA,QAAI,SAAS,CAAC,SAAd,EAAyB;AACrB,MAAA,KAAK,GAAG,UAAU,CAAC,KAAD,CAAlB;;AACA,UAAI,KAAK,CAAC,MAAN,GAAe,SAAS,CAAC,SAA7B,EAAwC;AACpC,QAAA,MAAM,CAAC,kBAAP,CAA0B,wBAAwB,SAAS,CAAC,IAA5D,EAAmE,iBAAiB,SAAS,CAAC,IAA9F,EAAqG,KAArG;AACH;AACJ;;AAED,IAAA,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,KAAD,CAAhB;AACH,GApBD;AAsBA,MAAI,OAAO,GAAG,CAAd;;AACA,MAAI,WAAW,CAAC,OAAZ,IAAuB,IAA3B,EAAiC;AAC7B;AACA,IAAA,OAAO,GAAG,WAAW,CAAC,OAAtB;;AAEA,QAAI,OAAO,OAAP,KAAoB,QAAxB,EAAkC;AAC9B,MAAA,MAAM,CAAC,kBAAP,CAA0B,6BAA1B,EAAyD,aAAzD,EAAwE,WAAxE;AACH;AAEJ,GARD,MAQO,IAAI,SAAS,IAAI,CAAC,WAAW,CAAC,SAAD,CAAzB,IAAwC,SAAS,CAAC,CAAV,GAAc,EAA1D,EAA8D;AACjE;AACA,IAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,SAAS,CAAC,CAAV,GAAc,EAAf,IAAqB,CAAhC,CAAV;AACH,GAvCgF,CAyCjF;;;AACA,MAAI,OAAO,KAAK,CAAhB,EAAmB;AACf,IAAA,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,OAAD,CAAhB,EADe,CACa;;AAC5B,IAAA,GAAG,CAAC,IAAJ,CAAS,IAAT;AACA,IAAA,GAAG,CAAC,IAAJ,CAAS,IAAT;AACH,GA9CgF,CAgDjF;;;AACA,MAAI,CAAC,SAAL,EAAgB;AACZ,WAAO,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAP;AACH,GAnDgF,CAqDjF;AACA;;;AACA,QAAM,GAAG,GAAG,cAAc,CAAC,SAAD,CAA1B,CAvDiF,CAyDjF;;AACA,MAAI,CAAC,GAAG,KAAK,GAAG,CAAC,aAAjB;;AACA,MAAI,OAAO,KAAK,CAAhB,EAAmB;AACf,IAAA,GAAG,CAAC,GAAJ;AACA,IAAA,GAAG,CAAC,GAAJ;AACA,IAAA,GAAG,CAAC,GAAJ;AACA,IAAA,CAAC,IAAI,OAAO,GAAG,CAAV,GAAc,CAAnB,CAJe,CAMf;;AACA,QAAI,GAAG,CAAC,CAAJ,GAAQ,EAAR,IAAc,GAAG,CAAC,CAAJ,KAAU,CAA5B,EAA+B;AAC1B,MAAA,MAAM,CAAC,kBAAP,CAA0B,0CAA1B,EAAsE,WAAtE,EAAmF,SAAnF;AACJ;AACJ,GAVD,MAUO,IAAI,GAAG,CAAC,CAAJ,KAAU,CAAd,EAAiB;AACnB,IAAA,MAAM,CAAC,kBAAP,CAA0B,0CAA1B,EAAsE,WAAtE,EAAmF,SAAnF;AACJ;;AAED,EAAA,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,CAAD,CAAhB;AACA,EAAA,GAAG,CAAC,IAAJ,CAAS,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAL,CAAT,CAAnB;AACA,EAAA,GAAG,CAAC,IAAJ,CAAS,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAL,CAAT,CAAnB;AAEA,SAAO,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAP;AACH;AAED,OAAM,SAAU,KAAV,CAAgB,cAAhB,EAAyC;AAC3C,QAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,cAAX,CAApB;;AAEA,MAAI,WAAW,CAAC,MAAZ,KAAuB,CAAvB,IAA4B,WAAW,CAAC,MAAZ,KAAuB,CAAvD,EAA0D;AACtD,IAAA,MAAM,CAAC,kBAAP,CAA0B,yBAA1B,EAAqD,gBAArD,EAAuE,cAAvE;AACH;;AAED,QAAM,EAAE,GAAgB;AACpB,IAAA,KAAK,EAAK,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6B,QAA7B,EADU;AAEpB,IAAA,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAFF;AAGpB,IAAA,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAHF;AAIpB,IAAA,EAAE,EAAQ,aAAa,CAAC,WAAW,CAAC,CAAD,CAAZ,CAJH;AAKpB,IAAA,KAAK,EAAK,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CALF;AAMpB,IAAA,IAAI,EAAM,WAAW,CAAC,CAAD,CAND;AAOpB,IAAA,OAAO,EAAG;AAPU,GAAxB,CAP2C,CAiB3C;;AACA,MAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;AAAE,WAAO,EAAP;AAAY;;AAE5C,MAAI;AACA,IAAA,EAAE,CAAC,CAAH,GAAO,SAAS,CAAC,IAAV,CAAe,WAAW,CAAC,CAAD,CAA1B,EAA+B,QAA/B,EAAP;AAEH,GAHD,CAGE,OAAO,KAAP,EAAc;AACZ,IAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,WAAO,EAAP;AACH;;AAED,EAAA,EAAE,CAAC,CAAH,GAAO,UAAU,CAAC,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAjB;AACA,EAAA,EAAE,CAAC,CAAH,GAAO,UAAU,CAAC,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAjB;;AAEA,MAAI,SAAS,CAAC,IAAV,CAAe,EAAE,CAAC,CAAlB,EAAqB,MAArB,MAAiC,SAAS,CAAC,IAAV,CAAe,EAAE,CAAC,CAAlB,EAAqB,MAArB,EAArC,EAAoE;AAChE;AACA,IAAA,EAAE,CAAC,OAAH,GAAa,EAAE,CAAC,CAAhB;AACA,IAAA,EAAE,CAAC,CAAH,GAAO,CAAP;AAEH,GALD,MAKO;AACH;AAEA,IAAA,EAAE,CAAC,OAAH,GAAa,IAAI,CAAC,KAAL,CAAW,CAAC,EAAE,CAAC,CAAH,GAAO,EAAR,IAAc,CAAzB,CAAb;;AACA,QAAI,EAAE,CAAC,OAAH,GAAa,CAAjB,EAAoB;AAAE,MAAA,EAAE,CAAC,OAAH,GAAa,CAAb;AAAiB;;AAEvC,QAAI,aAAa,GAAG,EAAE,CAAC,CAAH,GAAO,EAA3B;AAEA,UAAM,GAAG,GAAG,WAAW,CAAC,KAAZ,CAAkB,CAAlB,EAAqB,CAArB,CAAZ;;AAEA,QAAI,EAAE,CAAC,OAAH,KAAe,CAAnB,EAAsB;AAClB,MAAA,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,EAAE,CAAC,OAAJ,CAAhB;AACA,MAAA,GAAG,CAAC,IAAJ,CAAS,IAAT;AACA,MAAA,GAAG,CAAC,IAAJ,CAAS,IAAT;AACA,MAAA,aAAa,IAAI,EAAE,CAAC,OAAH,GAAa,CAAb,GAAiB,CAAlC;AACH;;AAED,UAAM,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAD,CAAxB;;AACA,QAAI;AACA,MAAA,EAAE,CAAC,IAAH,GAAU,cAAc,CAAC,MAAD,EAAS;AAAE,QAAA,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,CAAJ,CAAZ;AAAoB,QAAA,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,CAAJ,CAA9B;AAAsC,QAAA,aAAa,EAAE;AAArD,OAAT,CAAxB;AACH,KAFD,CAEE,OAAO,KAAP,EAAc;AACZ,MAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACH;;AAED,IAAA,EAAE,CAAC,IAAH,GAAU,SAAS,CAAC,cAAD,CAAnB;AACH;;AAED,SAAO,EAAP;AACH","sourceRoot":"","sourcesContent":["\"use strict\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { arrayify, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\r\nimport { Zero } from \"@ethersproject/constants\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { checkProperties } from \"@ethersproject/properties\";\r\nimport * as RLP from \"@ethersproject/rlp\";\r\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n///////////////////////////////\r\nfunction handleAddress(value) {\r\n    if (value === \"0x\") {\r\n        return null;\r\n    }\r\n    return getAddress(value);\r\n}\r\nfunction handleNumber(value) {\r\n    if (value === \"0x\") {\r\n        return Zero;\r\n    }\r\n    return BigNumber.from(value);\r\n}\r\nconst transactionFields = [\r\n    { name: \"nonce\", maxLength: 32, numeric: true },\r\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\r\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\r\n    { name: \"to\", length: 20 },\r\n    { name: \"value\", maxLength: 32, numeric: true },\r\n    { name: \"data\" },\r\n];\r\nconst allowedTransactionKeys = {\r\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\r\n};\r\nexport function computeAddress(key) {\r\n    const publicKey = computePublicKey(key);\r\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\r\n}\r\nexport function recoverAddress(digest, signature) {\r\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\r\n}\r\nexport function serialize(transaction, signature) {\r\n    checkProperties(transaction, allowedTransactionKeys);\r\n    const raw = [];\r\n    transactionFields.forEach(function (fieldInfo) {\r\n        let value = transaction[fieldInfo.name] || ([]);\r\n        const options = {};\r\n        if (fieldInfo.numeric) {\r\n            options.hexPad = \"left\";\r\n        }\r\n        value = arrayify(hexlify(value, options));\r\n        // Fixed-width field\r\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\r\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\r\n        }\r\n        // Variable-width (with a maximum)\r\n        if (fieldInfo.maxLength) {\r\n            value = stripZeros(value);\r\n            if (value.length > fieldInfo.maxLength) {\r\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\r\n            }\r\n        }\r\n        raw.push(hexlify(value));\r\n    });\r\n    let chainId = 0;\r\n    if (transaction.chainId != null) {\r\n        // A chainId was provided; if non-zero we'll use EIP-155\r\n        chainId = transaction.chainId;\r\n        if (typeof (chainId) !== \"number\") {\r\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\r\n        }\r\n    }\r\n    else if (signature && !isBytesLike(signature) && signature.v > 28) {\r\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\r\n        chainId = Math.floor((signature.v - 35) / 2);\r\n    }\r\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\r\n    if (chainId !== 0) {\r\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\r\n        raw.push(\"0x\");\r\n        raw.push(\"0x\");\r\n    }\r\n    // Requesting an unsigned transation\r\n    if (!signature) {\r\n        return RLP.encode(raw);\r\n    }\r\n    // The splitSignature will ensure the transaction has a recoveryParam in the\r\n    // case that the signTransaction function only adds a v.\r\n    const sig = splitSignature(signature);\r\n    // We pushed a chainId and null r, s on for hashing only; remove those\r\n    let v = 27 + sig.recoveryParam;\r\n    if (chainId !== 0) {\r\n        raw.pop();\r\n        raw.pop();\r\n        raw.pop();\r\n        v += chainId * 2 + 8;\r\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\r\n        if (sig.v > 28 && sig.v !== v) {\r\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\r\n        }\r\n    }\r\n    else if (sig.v !== v) {\r\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\r\n    }\r\n    raw.push(hexlify(v));\r\n    raw.push(stripZeros(arrayify(sig.r)));\r\n    raw.push(stripZeros(arrayify(sig.s)));\r\n    return RLP.encode(raw);\r\n}\r\nexport function parse(rawTransaction) {\r\n    const transaction = RLP.decode(rawTransaction);\r\n    if (transaction.length !== 9 && transaction.length !== 6) {\r\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\r\n    }\r\n    const tx = {\r\n        nonce: handleNumber(transaction[0]).toNumber(),\r\n        gasPrice: handleNumber(transaction[1]),\r\n        gasLimit: handleNumber(transaction[2]),\r\n        to: handleAddress(transaction[3]),\r\n        value: handleNumber(transaction[4]),\r\n        data: transaction[5],\r\n        chainId: 0\r\n    };\r\n    // Legacy unsigned transaction\r\n    if (transaction.length === 6) {\r\n        return tx;\r\n    }\r\n    try {\r\n        tx.v = BigNumber.from(transaction[6]).toNumber();\r\n    }\r\n    catch (error) {\r\n        console.log(error);\r\n        return tx;\r\n    }\r\n    tx.r = hexZeroPad(transaction[7], 32);\r\n    tx.s = hexZeroPad(transaction[8], 32);\r\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\r\n        // EIP-155 unsigned transaction\r\n        tx.chainId = tx.v;\r\n        tx.v = 0;\r\n    }\r\n    else {\r\n        // Signed Tranasaction\r\n        tx.chainId = Math.floor((tx.v - 35) / 2);\r\n        if (tx.chainId < 0) {\r\n            tx.chainId = 0;\r\n        }\r\n        let recoveryParam = tx.v - 27;\r\n        const raw = transaction.slice(0, 6);\r\n        if (tx.chainId !== 0) {\r\n            raw.push(hexlify(tx.chainId));\r\n            raw.push(\"0x\");\r\n            raw.push(\"0x\");\r\n            recoveryParam -= tx.chainId * 2 + 8;\r\n        }\r\n        const digest = keccak256(RLP.encode(raw));\r\n        try {\r\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\r\n        }\r\n        catch (error) {\r\n            console.log(error);\r\n        }\r\n        tx.hash = keccak256(rawTransaction);\r\n    }\r\n    return tx;\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}