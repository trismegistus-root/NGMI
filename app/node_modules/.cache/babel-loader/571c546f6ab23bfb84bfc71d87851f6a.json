{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"C:/ngmi/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/ngmi/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nvar _constructorGuard = {};\nvar Zero = BigNumber.from(0);\nvar NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message, fault, operation, value) {\n  var params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value !== undefined) {\n    params.value = value;\n  }\n\n  return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n} // Constant to pull zeros from for multipliers\n\n\nvar zeros = \"0\";\n\nwhile (zeros.length < 256) {\n  zeros += zeros;\n} // Returns a string \"1\" followed by decimal \"0\"s\n\n\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  var multiplier = getMultiplier(decimals); // Make sure wei is a big number (convert as necessary)\n\n  value = BigNumber.from(value);\n  var negative = value.lt(Zero);\n\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n\n  var fraction = value.mod(multiplier).toString();\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  } // Strip training 0\n\n\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  var whole = value.div(multiplier).toString();\n  value = whole + \".\" + fraction;\n\n  if (negative) {\n    value = \"-\" + value;\n  }\n\n  return value;\n}\nexport function parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  var multiplier = getMultiplier(decimals);\n\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  }\n\n  if (multiplier.length - 1 === 0) {\n    return BigNumber.from(value);\n  } // Is it negative?\n\n\n  var negative = value.substring(0, 1) === \"-\";\n\n  if (negative) {\n    value = value.substring(1);\n  }\n\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  } // Split it into a whole and fractional part\n\n\n  var comps = value.split(\".\");\n\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n\n  var whole = comps[0],\n      fraction = comps[1];\n\n  if (!whole) {\n    whole = \"0\";\n  }\n\n  if (!fraction) {\n    fraction = \"0\";\n  } // Prevent underflow\n\n\n  if (fraction.length > multiplier.length - 1) {\n    throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n  } // Fully pad the string with zeros to get to wei\n\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n\n  var wholeValue = BigNumber.from(whole);\n  var fractionValue = BigNumber.from(fraction);\n  var wei = wholeValue.mul(multiplier).add(fractionValue);\n\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n\n  return wei;\n}\nexport var FixedFormat = /*#__PURE__*/function () {\n  function FixedFormat(constructorGuard, signed, width, decimals) {\n    _classCallCheck(this, FixedFormat);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n\n  _createClass(FixedFormat, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof FixedFormat) {\n        return value;\n      }\n\n      var signed = true;\n      var width = 128;\n      var decimals = 18;\n\n      if (typeof value === \"string\") {\n        if (value === \"fixed\") {// defaults...\n        } else if (value === \"ufixed\") {\n          signed = false;\n        } else if (value != null) {\n          var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\n          if (!match) {\n            logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n          }\n\n          signed = match[1] !== \"u\";\n          width = parseInt(match[2]);\n          decimals = parseInt(match[3]);\n        }\n      } else if (value) {\n        var check = function check(key, type, defaultValue) {\n          if (value[key] == null) {\n            return defaultValue;\n          }\n\n          if (typeof value[key] !== type) {\n            logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n          }\n\n          return value[key];\n        };\n\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n      }\n\n      if (width % 8) {\n        logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n      }\n\n      if (decimals > 80) {\n        logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n      }\n\n      return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n  }]);\n\n  return FixedFormat;\n}();\nexport var FixedNumber = /*#__PURE__*/function () {\n  function FixedNumber(constructorGuard, hex, value, format) {\n    _classCallCheck(this, FixedNumber);\n\n    logger.checkNew(this instanceof FixedNumber ? this.constructor : void 0, FixedNumber);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n\n  _createClass(FixedNumber, [{\n    key: \"_checkFormat\",\n    value: function _checkFormat(other) {\n      if (this.format.name !== other.format.name) {\n        logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n      }\n    }\n  }, {\n    key: \"addUnsafe\",\n    value: function addUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"subUnsafe\",\n    value: function subUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"mulUnsafe\",\n    value: function mulUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"divUnsafe\",\n    value: function divUnsafe(other) {\n      this._checkFormat(other);\n\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"floor\",\n    value: function floor() {\n      var comps = this.toString().split(\".\");\n      var result = FixedNumber.from(comps[0], this.format);\n      var hasFraction = !comps[1].match(/^(0*)$/);\n\n      if (this.isNegative() && hasFraction) {\n        result = result.subUnsafe(ONE);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"ceiling\",\n    value: function ceiling() {\n      var comps = this.toString().split(\".\");\n      var result = FixedNumber.from(comps[0], this.format);\n      var hasFraction = !comps[1].match(/^(0*)$/);\n\n      if (!this.isNegative() && hasFraction) {\n        result = result.addUnsafe(ONE);\n      }\n\n      return result;\n    } // @TODO: Support other rounding algorithms\n\n  }, {\n    key: \"round\",\n    value: function round(decimals) {\n      if (decimals == null) {\n        decimals = 0;\n      } // If we are already in range, we're done\n\n\n      var comps = this.toString().split(\".\");\n\n      if (decimals < 0 || decimals > 80 || decimals % 1) {\n        logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n      }\n\n      if (comps[1].length <= decimals) {\n        return this;\n      }\n\n      var factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals));\n      return this.mulUnsafe(factor).addUnsafe(BUMP).floor().divUnsafe(factor);\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this._value === \"0.0\";\n    }\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return this._value[0] === \"-\";\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._value;\n    }\n  }, {\n    key: \"toHexString\",\n    value: function toHexString(width) {\n      if (width == null) {\n        return this._hex;\n      }\n\n      if (width % 8) {\n        logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n      }\n\n      var hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n      return hexZeroPad(hex, width / 8);\n    }\n  }, {\n    key: \"toUnsafeFloat\",\n    value: function toUnsafeFloat() {\n      return parseFloat(this.toString());\n    }\n  }, {\n    key: \"toFormat\",\n    value: function toFormat(format) {\n      return FixedNumber.fromString(this._value, format);\n    }\n  }], [{\n    key: \"fromValue\",\n    value: function fromValue(value, decimals, format) {\n      // If decimals looks more like a format, and there is no format, shift the parameters\n      if (format == null && decimals != null && !isBigNumberish(decimals)) {\n        format = decimals;\n        decimals = null;\n      }\n\n      if (decimals == null) {\n        decimals = 0;\n      }\n\n      if (format == null) {\n        format = \"fixed\";\n      }\n\n      return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, format) {\n      if (format == null) {\n        format = \"fixed\";\n      }\n\n      var fixedFormat = FixedFormat.from(format);\n      var numeric = parseFixed(value, fixedFormat.decimals);\n\n      if (!fixedFormat.signed && numeric.lt(Zero)) {\n        throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n      }\n\n      var hex = null;\n\n      if (fixedFormat.signed) {\n        hex = numeric.toTwos(fixedFormat.width).toHexString();\n      } else {\n        hex = numeric.toHexString();\n        hex = hexZeroPad(hex, fixedFormat.width / 8);\n      }\n\n      var decimal = formatFixed(numeric, fixedFormat.decimals);\n      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(value, format) {\n      if (format == null) {\n        format = \"fixed\";\n      }\n\n      var fixedFormat = FixedFormat.from(format);\n\n      if (arrayify(value).length > fixedFormat.width / 8) {\n        throw new Error(\"overflow\");\n      }\n\n      var numeric = BigNumber.from(value);\n\n      if (fixedFormat.signed) {\n        numeric = numeric.fromTwos(fixedFormat.width);\n      }\n\n      var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n      var decimal = formatFixed(numeric, fixedFormat.decimals);\n      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n  }, {\n    key: \"from\",\n    value: function from(value, format) {\n      if (typeof value === \"string\") {\n        return FixedNumber.fromString(value, format);\n      }\n\n      if (isBytes(value)) {\n        return FixedNumber.fromBytes(value, format);\n      }\n\n      try {\n        return FixedNumber.fromValue(value, 0, format);\n      } catch (error) {\n        // Allow NUMERIC_FAULT to bubble up\n        if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n          throw error;\n        }\n      }\n\n      return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n  }, {\n    key: \"isFixedNumber\",\n    value: function isFixedNumber(value) {\n      return !!(value && value._isFixedNumber);\n    }\n  }]);\n\n  return FixedNumber;\n}();\nvar ONE = FixedNumber.from(1);\nvar BUMP = FixedNumber.from(\"0.5\");","map":{"version":3,"sources":["../src.ts/fixednumber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\r\nconst _constructorGuard = {};\r\nconst Zero = BigNumber.from(0);\r\nconst NegativeOne = BigNumber.from(-1);\r\nfunction throwFault(message, fault, operation, value) {\r\n    const params = { fault: fault, operation: operation };\r\n    if (value !== undefined) {\r\n        params.value = value;\r\n    }\r\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\r\n}\r\n// Constant to pull zeros from for multipliers\r\nlet zeros = \"0\";\r\nwhile (zeros.length < 256) {\r\n    zeros += zeros;\r\n}\r\n// Returns a string \"1\" followed by decimal \"0\"s\r\nfunction getMultiplier(decimals) {\r\n    if (typeof (decimals) !== \"number\") {\r\n        try {\r\n            decimals = BigNumber.from(decimals).toNumber();\r\n        }\r\n        catch (e) { }\r\n    }\r\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\r\n        return (\"1\" + zeros.substring(0, decimals));\r\n    }\r\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\r\n}\r\nexport function formatFixed(value, decimals) {\r\n    if (decimals == null) {\r\n        decimals = 0;\r\n    }\r\n    const multiplier = getMultiplier(decimals);\r\n    // Make sure wei is a big number (convert as necessary)\r\n    value = BigNumber.from(value);\r\n    const negative = value.lt(Zero);\r\n    if (negative) {\r\n        value = value.mul(NegativeOne);\r\n    }\r\n    let fraction = value.mod(multiplier).toString();\r\n    while (fraction.length < multiplier.length - 1) {\r\n        fraction = \"0\" + fraction;\r\n    }\r\n    // Strip training 0\r\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\r\n    const whole = value.div(multiplier).toString();\r\n    value = whole + \".\" + fraction;\r\n    if (negative) {\r\n        value = \"-\" + value;\r\n    }\r\n    return value;\r\n}\r\nexport function parseFixed(value, decimals) {\r\n    if (decimals == null) {\r\n        decimals = 0;\r\n    }\r\n    const multiplier = getMultiplier(decimals);\r\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\r\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\r\n    }\r\n    if (multiplier.length - 1 === 0) {\r\n        return BigNumber.from(value);\r\n    }\r\n    // Is it negative?\r\n    const negative = (value.substring(0, 1) === \"-\");\r\n    if (negative) {\r\n        value = value.substring(1);\r\n    }\r\n    if (value === \".\") {\r\n        logger.throwArgumentError(\"missing value\", \"value\", value);\r\n    }\r\n    // Split it into a whole and fractional part\r\n    const comps = value.split(\".\");\r\n    if (comps.length > 2) {\r\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\r\n    }\r\n    let whole = comps[0], fraction = comps[1];\r\n    if (!whole) {\r\n        whole = \"0\";\r\n    }\r\n    if (!fraction) {\r\n        fraction = \"0\";\r\n    }\r\n    // Prevent underflow\r\n    if (fraction.length > multiplier.length - 1) {\r\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\r\n    }\r\n    // Fully pad the string with zeros to get to wei\r\n    while (fraction.length < multiplier.length - 1) {\r\n        fraction += \"0\";\r\n    }\r\n    const wholeValue = BigNumber.from(whole);\r\n    const fractionValue = BigNumber.from(fraction);\r\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\r\n    if (negative) {\r\n        wei = wei.mul(NegativeOne);\r\n    }\r\n    return wei;\r\n}\r\nexport class FixedFormat {\r\n    constructor(constructorGuard, signed, width, decimals) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new FixedFormat\"\r\n            });\r\n        }\r\n        this.signed = signed;\r\n        this.width = width;\r\n        this.decimals = decimals;\r\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\r\n        this._multiplier = getMultiplier(decimals);\r\n        Object.freeze(this);\r\n    }\r\n    static from(value) {\r\n        if (value instanceof FixedFormat) {\r\n            return value;\r\n        }\r\n        let signed = true;\r\n        let width = 128;\r\n        let decimals = 18;\r\n        if (typeof (value) === \"string\") {\r\n            if (value === \"fixed\") {\r\n                // defaults...\r\n            }\r\n            else if (value === \"ufixed\") {\r\n                signed = false;\r\n            }\r\n            else if (value != null) {\r\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\r\n                if (!match) {\r\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\r\n                }\r\n                signed = (match[1] !== \"u\");\r\n                width = parseInt(match[2]);\r\n                decimals = parseInt(match[3]);\r\n            }\r\n        }\r\n        else if (value) {\r\n            const check = (key, type, defaultValue) => {\r\n                if (value[key] == null) {\r\n                    return defaultValue;\r\n                }\r\n                if (typeof (value[key]) !== type) {\r\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\r\n                }\r\n                return value[key];\r\n            };\r\n            signed = check(\"signed\", \"boolean\", signed);\r\n            width = check(\"width\", \"number\", width);\r\n            decimals = check(\"decimals\", \"number\", decimals);\r\n        }\r\n        if (width % 8) {\r\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\r\n        }\r\n        if (decimals > 80) {\r\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\r\n        }\r\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\r\n    }\r\n}\r\nexport class FixedNumber {\r\n    constructor(constructorGuard, hex, value, format) {\r\n        logger.checkNew(new.target, FixedNumber);\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new FixedFormat\"\r\n            });\r\n        }\r\n        this.format = format;\r\n        this._hex = hex;\r\n        this._value = value;\r\n        this._isFixedNumber = true;\r\n        Object.freeze(this);\r\n    }\r\n    _checkFormat(other) {\r\n        if (this.format.name !== other.format.name) {\r\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\r\n        }\r\n    }\r\n    addUnsafe(other) {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\r\n    }\r\n    subUnsafe(other) {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\r\n    }\r\n    mulUnsafe(other) {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\r\n    }\r\n    divUnsafe(other) {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\r\n    }\r\n    floor() {\r\n        let comps = this.toString().split(\".\");\r\n        let result = FixedNumber.from(comps[0], this.format);\r\n        const hasFraction = !comps[1].match(/^(0*)$/);\r\n        if (this.isNegative() && hasFraction) {\r\n            result = result.subUnsafe(ONE);\r\n        }\r\n        return result;\r\n    }\r\n    ceiling() {\r\n        let comps = this.toString().split(\".\");\r\n        let result = FixedNumber.from(comps[0], this.format);\r\n        const hasFraction = !comps[1].match(/^(0*)$/);\r\n        if (!this.isNegative() && hasFraction) {\r\n            result = result.addUnsafe(ONE);\r\n        }\r\n        return result;\r\n    }\r\n    // @TODO: Support other rounding algorithms\r\n    round(decimals) {\r\n        if (decimals == null) {\r\n            decimals = 0;\r\n        }\r\n        // If we are already in range, we're done\r\n        let comps = this.toString().split(\".\");\r\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\r\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\r\n        }\r\n        if (comps[1].length <= decimals) {\r\n            return this;\r\n        }\r\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals));\r\n        return this.mulUnsafe(factor).addUnsafe(BUMP).floor().divUnsafe(factor);\r\n    }\r\n    isZero() {\r\n        return (this._value === \"0.0\");\r\n    }\r\n    isNegative() {\r\n        return (this._value[0] === \"-\");\r\n    }\r\n    toString() { return this._value; }\r\n    toHexString(width) {\r\n        if (width == null) {\r\n            return this._hex;\r\n        }\r\n        if (width % 8) {\r\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\r\n        }\r\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\r\n        return hexZeroPad(hex, width / 8);\r\n    }\r\n    toUnsafeFloat() { return parseFloat(this.toString()); }\r\n    toFormat(format) {\r\n        return FixedNumber.fromString(this._value, format);\r\n    }\r\n    static fromValue(value, decimals, format) {\r\n        // If decimals looks more like a format, and there is no format, shift the parameters\r\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\r\n            format = decimals;\r\n            decimals = null;\r\n        }\r\n        if (decimals == null) {\r\n            decimals = 0;\r\n        }\r\n        if (format == null) {\r\n            format = \"fixed\";\r\n        }\r\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\r\n    }\r\n    static fromString(value, format) {\r\n        if (format == null) {\r\n            format = \"fixed\";\r\n        }\r\n        const fixedFormat = FixedFormat.from(format);\r\n        const numeric = parseFixed(value, fixedFormat.decimals);\r\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\r\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\r\n        }\r\n        let hex = null;\r\n        if (fixedFormat.signed) {\r\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\r\n        }\r\n        else {\r\n            hex = numeric.toHexString();\r\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\r\n        }\r\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\r\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\r\n    }\r\n    static fromBytes(value, format) {\r\n        if (format == null) {\r\n            format = \"fixed\";\r\n        }\r\n        const fixedFormat = FixedFormat.from(format);\r\n        if (arrayify(value).length > fixedFormat.width / 8) {\r\n            throw new Error(\"overflow\");\r\n        }\r\n        let numeric = BigNumber.from(value);\r\n        if (fixedFormat.signed) {\r\n            numeric = numeric.fromTwos(fixedFormat.width);\r\n        }\r\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\r\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\r\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\r\n    }\r\n    static from(value, format) {\r\n        if (typeof (value) === \"string\") {\r\n            return FixedNumber.fromString(value, format);\r\n        }\r\n        if (isBytes(value)) {\r\n            return FixedNumber.fromBytes(value, format);\r\n        }\r\n        try {\r\n            return FixedNumber.fromValue(value, 0, format);\r\n        }\r\n        catch (error) {\r\n            // Allow NUMERIC_FAULT to bubble up\r\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\r\n                throw error;\r\n            }\r\n        }\r\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\r\n    }\r\n    static isFixedNumber(value) {\r\n        return !!(value && value._isFixedNumber);\r\n    }\r\n}\r\nconst ONE = FixedNumber.from(1);\r\nconst BUMP = FixedNumber.from(\"0.5\");\r\n//# sourceMappingURL=fixednumber.js.map"]},"metadata":{},"sourceType":"module"}