{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nvar buffer_1 = require(\"buffer\");\n\nvar transaction_1 = require(\"./transaction\");\n/**\r\n * Creates a new transaction object that doesn't need to be signed.\r\n *\r\n * @param data - A transaction can be initialized with its rlp representation, an array containing\r\n * the value of its fields in order, or an object containing them by name.\r\n *\r\n * @param opts - The transaction's options, used to indicate the chain and hardfork the\r\n * transactions belongs to.\r\n *\r\n * @see Transaction\r\n */\n\n\nvar FakeTransaction =\n/** @class */\nfunction (_super) {\n  __extends(FakeTransaction, _super);\n\n  function FakeTransaction(data, opts) {\n    if (data === void 0) {\n      data = {};\n    }\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var _this = _super.call(this, data, opts) || this;\n\n    Object.defineProperty(_this, 'from', {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return _this.getSenderAddress();\n      },\n      set: function (val) {\n        if (val) {\n          _this._from = ethereumjs_util_1.toBuffer(val);\n        }\n      }\n    });\n    var txData = data;\n\n    if (txData.from) {\n      _this.from = ethereumjs_util_1.toBuffer(txData.from);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Computes a sha3-256 hash of the serialized tx, using the sender address to generate a fake\r\n   * signature.\r\n   *\r\n   * @param includeSignature - Whether or not to include the signature\r\n   */\n\n\n  FakeTransaction.prototype.hash = function (includeSignature) {\n    if (includeSignature === void 0) {\n      includeSignature = true;\n    }\n\n    if (includeSignature && this._from && this._from.toString('hex') !== '') {\n      // include a fake signature using the from address as a private key\n      var fakeKey = buffer_1.Buffer.concat([this._from, this._from.slice(0, 12)]);\n      this.sign(fakeKey);\n    }\n\n    return _super.prototype.hash.call(this, includeSignature);\n  };\n\n  return FakeTransaction;\n}(transaction_1.default);\n\nexports.default = FakeTransaction;","map":{"version":3,"sources":["../src/fake.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA;;;;;;;;;;AAUG;;;AACH,IAAA,eAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA6C,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AAO3C,WAAA,eAAA,CACE,IADF,EAEE,IAFF,EAE+B;AAD7B,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,EAAA;AAAiE;;AACjE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,EAAA;AAA6B;;AAF/B,QAAA,KAAA,GAIE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,IAAZ,KAAiB,IAJnB;;AAME,IAAA,MAAM,CAAC,cAAP,CAAsB,KAAtB,EAA4B,MAA5B,EAAoC;AAClC,MAAA,UAAU,EAAE,IADsB;AAElC,MAAA,YAAY,EAAE,IAFoB;AAGlC,MAAA,GAAG,EAAE,YAAA;AAAM,eAAA,KAAI,CAAJ,gBAAA,EAAA;AAAuB,OAHA;AAIlC,MAAA,GAAG,EAAE,UAAA,GAAA,EAAG;AACN,YAAI,GAAJ,EAAS;AACP,UAAA,KAAI,CAAC,KAAL,GAAa,iBAAA,CAAA,QAAA,CAAS,GAAT,CAAb;AACD;AACF;AARiC,KAApC;AAWA,QAAM,MAAM,GAAG,IAAf;;AACA,QAAI,MAAM,CAAC,IAAX,EAAiB;AACf,MAAA,KAAI,CAAC,IAAL,GAAY,iBAAA,CAAA,QAAA,CAAS,MAAM,CAAC,IAAhB,CAAZ;AACD;;;AACF;AAED;;;;;AAKG;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,gBAAL,EAA4B;AAAvB,QAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,gBAAA,GAAA,IAAA;AAAuB;;AAC1B,QAAI,gBAAgB,IAAI,KAAK,KAAzB,IAAkC,KAAK,KAAL,CAAW,QAAX,CAAoB,KAApB,MAA+B,EAArE,EAAyE;AACvE;AACA,UAAM,OAAO,GAAG,QAAA,CAAA,MAAA,CAAO,MAAP,CAAc,CAAC,KAAK,KAAN,EAAa,KAAK,KAAL,CAAW,KAAX,CAAiB,CAAjB,EAAoB,EAApB,CAAb,CAAd,CAAhB;AACA,WAAK,IAAL,CAAU,OAAV;AACD;;AAED,WAAO,MAAA,CAAA,SAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV,EAAW,gBAAX,CAAP;AACD,GARD;;AASF,SAAA,eAAA;AAAC,CA7CD,CAA6C,aAAA,CAAA,OAA7C,CAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\r\nvar buffer_1 = require(\"buffer\");\r\nvar transaction_1 = require(\"./transaction\");\r\n/**\r\n * Creates a new transaction object that doesn't need to be signed.\r\n *\r\n * @param data - A transaction can be initialized with its rlp representation, an array containing\r\n * the value of its fields in order, or an object containing them by name.\r\n *\r\n * @param opts - The transaction's options, used to indicate the chain and hardfork the\r\n * transactions belongs to.\r\n *\r\n * @see Transaction\r\n */\r\nvar FakeTransaction = /** @class */ (function (_super) {\r\n    __extends(FakeTransaction, _super);\r\n    function FakeTransaction(data, opts) {\r\n        if (data === void 0) { data = {}; }\r\n        if (opts === void 0) { opts = {}; }\r\n        var _this = _super.call(this, data, opts) || this;\r\n        Object.defineProperty(_this, 'from', {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: function () { return _this.getSenderAddress(); },\r\n            set: function (val) {\r\n                if (val) {\r\n                    _this._from = ethereumjs_util_1.toBuffer(val);\r\n                }\r\n            },\r\n        });\r\n        var txData = data;\r\n        if (txData.from) {\r\n            _this.from = ethereumjs_util_1.toBuffer(txData.from);\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Computes a sha3-256 hash of the serialized tx, using the sender address to generate a fake\r\n     * signature.\r\n     *\r\n     * @param includeSignature - Whether or not to include the signature\r\n     */\r\n    FakeTransaction.prototype.hash = function (includeSignature) {\r\n        if (includeSignature === void 0) { includeSignature = true; }\r\n        if (includeSignature && this._from && this._from.toString('hex') !== '') {\r\n            // include a fake signature using the from address as a private key\r\n            var fakeKey = buffer_1.Buffer.concat([this._from, this._from.slice(0, 12)]);\r\n            this.sign(fakeKey);\r\n        }\r\n        return _super.prototype.hash.call(this, includeSignature);\r\n    };\r\n    return FakeTransaction;\r\n}(transaction_1.default));\r\nexports.default = FakeTransaction;\r\n//# sourceMappingURL=fake.js.map"]},"metadata":{},"sourceType":"script"}