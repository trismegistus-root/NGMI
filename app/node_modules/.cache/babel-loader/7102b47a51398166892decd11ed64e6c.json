{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/ngmi/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/ngmi/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar mh = require('multihashes');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar codecs = require('multicodec/src/base-table.json');\n\nvar CIDUtil = require('./cid-util');\n\nvar withIs = require('class-is');\n/**\r\n * @typedef {Object} SerializedCID\r\n * @param {string} codec\r\n * @param {number} version\r\n * @param {Buffer} multihash\r\n */\n\n/**\r\n * Test if the given input is a CID.\r\n * @function isCID\r\n * @memberof CID\r\n * @static\r\n * @param {any} other\r\n * @returns {bool}\r\n */\n\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n * @class CID\r\n */\n\n\nvar CID = /*#__PURE__*/function () {\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Buffer)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {string|Buffer|CID} version\r\n   * @param {string} [codec]\r\n   * @param {Buffer} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.buffer>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\n  function CID(version, codec, multihash, multibaseName) {\n    _classCallCheck(this, CID);\n\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      var cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash); // Default guard for when a CID < 0.7 is passed with no multibaseName\n\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      var baseName = multibase.isEncoded(version);\n\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        var _cid = multibase.decode(version);\n\n        this.version = parseInt(_cid.slice(0, 1).toString('hex'), 16);\n        this.codec = multicodec.getCodec(_cid.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n\n    if (Buffer.isBuffer(version)) {\n      var firstByte = version.slice(0, 1);\n      var v = parseInt(firstByte.toString('hex'), 16);\n\n      if (v === 1) {\n        // version is a CID buffer\n        var _cid2 = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(_cid2.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid2.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      return;\n    } // otherwise, assemble the CID from the parameters\n\n    /**\r\n     * @type {number}\r\n     */\n\n\n    this.version = version;\n    /**\r\n     * @type {string}\r\n     */\n\n    this.codec = codec;\n    /**\r\n     * @type {Buffer}\r\n     */\n\n    this.multihash = multihash;\n    /**\r\n     * @type {string}\r\n     */\n\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n  /**\r\n   * The CID as a `Buffer`\r\n   *\r\n   * @return {Buffer}\r\n   * @readonly\r\n   *\r\n   * @memberOf CID\r\n   */\n\n\n  _createClass(CID, [{\n    key: \"toV0\",\n\n    /**\r\n     * Convert to a CID of version `0`.\r\n     *\r\n     * @returns {CID}\r\n     */\n    value: function toV0() {\n      if (this.codec !== 'dag-pb') {\n        throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n      }\n\n      var _mh$decode = mh.decode(this.multihash),\n          name = _mh$decode.name,\n          length = _mh$decode.length;\n\n      if (name !== 'sha2-256') {\n        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n      }\n\n      if (length !== 32) {\n        throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n      }\n\n      return new _CID(0, this.codec, this.multihash);\n    }\n    /**\r\n     * Convert to a CID of version `1`.\r\n     *\r\n     * @returns {CID}\r\n     */\n\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      return new _CID(1, this.codec, this.multihash);\n    }\n    /**\r\n     * Encode the CID into a string.\r\n     *\r\n     * @param {string} [base=this.multibaseName] - Base encoding to use.\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"toBaseEncodedString\",\n    value: function toBaseEncodedString() {\n      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n\n      if (this.string && base === this.multibaseName) {\n        return this.string;\n      }\n\n      var str = null;\n\n      if (this.version === 0) {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n        }\n\n        str = mh.toB58String(this.multihash);\n      } else if (this.version === 1) {\n        str = multibase.encode(base, this.buffer).toString();\n      } else {\n        throw new Error('unsupported version');\n      }\n\n      if (base === this.multibaseName) {\n        // cache the string value\n        Object.defineProperty(this, 'string', {\n          value: str\n        });\n      }\n\n      return str;\n    }\n    /**\r\n     * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n     *\r\n     * @returns {String}\r\n     */\n\n  }, {\n    key: Symbol.for('nodejs.util.inspect.custom'),\n    value: function value() {\n      return 'CID(' + this.toString() + ')';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      return this.toBaseEncodedString(base);\n    }\n    /**\r\n     * Serialize to a plain object.\r\n     *\r\n     * @returns {SerializedCID}\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        codec: this.codec,\n        version: this.version,\n        hash: this.multihash\n      };\n    }\n    /**\r\n     * Compare equality with another CID.\r\n     *\r\n     * @param {CID} other\r\n     * @returns {bool}\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n    }\n    /**\r\n     * Test if the given input is a valid CID object.\r\n     * Throws if it is not.\r\n     *\r\n     * @param {any} other\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      var buffer = this._buffer;\n\n      if (!buffer) {\n        if (this.version === 0) {\n          buffer = this.multihash;\n        } else if (this.version === 1) {\n          buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n        } else {\n          throw new Error('unsupported version');\n        } // Cache this buffer so it doesn't have to be recreated\n\n\n        Object.defineProperty(this, '_buffer', {\n          value: buffer\n        });\n      }\n\n      return buffer;\n    }\n    /**\r\n     * Get the prefix of the CID.\r\n     *\r\n     * @returns {Buffer}\r\n     * @readonly\r\n     */\n\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      return Buffer.concat([Buffer.from(\"0\".concat(this.version), 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n    }\n  }], [{\n    key: \"validateCID\",\n    value: function validateCID(other) {\n      var errorMsg = CIDUtil.checkCIDComponents(other);\n\n      if (errorMsg) {\n        throw new Error(errorMsg);\n      }\n    }\n  }]);\n\n  return CID;\n}();\n\nvar _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"sources":["C:/ngmi/node_modules/cids/src/index.js"],"names":["require","Buffer","mh","multibase","multicodec","codecs","CIDUtil","withIs","CID","version","codec","multihash","multibaseName","_CID","isCID","cid","from","baseName","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","validateCID","Object","defineProperty","value","isBuffer","firstByte","v","Error","name","length","base","string","str","toB58String","encode","buffer","Symbol","for","toBaseEncodedString","hash","other","equals","_buffer","concat","getCodeVarint","prefix","errorMsg","checkCIDComponents","className","symbolName","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst { Buffer } = require('buffer')\r\nconst mh = require('multihashes')\r\nconst multibase = require('multibase')\r\nconst multicodec = require('multicodec')\r\nconst codecs = require('multicodec/src/base-table.json')\r\nconst CIDUtil = require('./cid-util')\r\nconst withIs = require('class-is')\r\n\r\n/**\r\n * @typedef {Object} SerializedCID\r\n * @param {string} codec\r\n * @param {number} version\r\n * @param {Buffer} multihash\r\n */\r\n\r\n/**\r\n * Test if the given input is a CID.\r\n * @function isCID\r\n * @memberof CID\r\n * @static\r\n * @param {any} other\r\n * @returns {bool}\r\n */\r\n\r\n/**\r\n * Class representing a CID `<mbase><version><mcodec><mhash>`\r\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\r\n * @class CID\r\n */\r\nclass CID {\r\n  /**\r\n   * Create a new CID.\r\n   *\r\n   * The algorithm for argument input is roughly:\r\n   * ```\r\n   * if (cid)\r\n   *   -> create a copy\r\n   * else if (str)\r\n   *   if (1st char is on multibase table) -> CID String\r\n   *   else -> bs58 encoded multihash\r\n   * else if (Buffer)\r\n   *   if (1st byte is 0 or 1) -> CID\r\n   *   else -> multihash\r\n   * else if (Number)\r\n   *   -> construct CID by parts\r\n   * ```\r\n   *\r\n   * @param {string|Buffer|CID} version\r\n   * @param {string} [codec]\r\n   * @param {Buffer} [multihash]\r\n   * @param {string} [multibaseName]\r\n   *\r\n   * @example\r\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\r\n   * new CID(<cidStr>)\r\n   * new CID(<cid.buffer>)\r\n   * new CID(<multihash>)\r\n   * new CID(<bs58 encoded multihash>)\r\n   * new CID(<cid>)\r\n   */\r\n  constructor (version, codec, multihash, multibaseName) {\r\n    if (_CID.isCID(version)) {\r\n      // version is an exising CID instance\r\n      const cid = version\r\n      this.version = cid.version\r\n      this.codec = cid.codec\r\n      this.multihash = Buffer.from(cid.multihash)\r\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\r\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\r\n      return\r\n    }\r\n\r\n    if (typeof version === 'string') {\r\n      // e.g. 'base32' or false\r\n      const baseName = multibase.isEncoded(version)\r\n      if (baseName) {\r\n        // version is a CID String encoded with multibase, so v1\r\n        const cid = multibase.decode(version)\r\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)\r\n        this.codec = multicodec.getCodec(cid.slice(1))\r\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\r\n        this.multibaseName = baseName\r\n      } else {\r\n        // version is a base58btc string multihash, so v0\r\n        this.version = 0\r\n        this.codec = 'dag-pb'\r\n        this.multihash = mh.fromB58String(version)\r\n        this.multibaseName = 'base58btc'\r\n      }\r\n      CID.validateCID(this)\r\n      Object.defineProperty(this, 'string', { value: version })\r\n      return\r\n    }\r\n\r\n    if (Buffer.isBuffer(version)) {\r\n      const firstByte = version.slice(0, 1)\r\n      const v = parseInt(firstByte.toString('hex'), 16)\r\n      if (v === 1) {\r\n        // version is a CID buffer\r\n        const cid = version\r\n        this.version = v\r\n        this.codec = multicodec.getCodec(cid.slice(1))\r\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\r\n        this.multibaseName = 'base32'\r\n      } else {\r\n        // version is a raw multihash buffer, so v0\r\n        this.version = 0\r\n        this.codec = 'dag-pb'\r\n        this.multihash = version\r\n        this.multibaseName = 'base58btc'\r\n      }\r\n      CID.validateCID(this)\r\n      return\r\n    }\r\n\r\n    // otherwise, assemble the CID from the parameters\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.version = version\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.codec = codec\r\n\r\n    /**\r\n     * @type {Buffer}\r\n     */\r\n    this.multihash = multihash\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\r\n\r\n    CID.validateCID(this)\r\n  }\r\n\r\n  /**\r\n   * The CID as a `Buffer`\r\n   *\r\n   * @return {Buffer}\r\n   * @readonly\r\n   *\r\n   * @memberOf CID\r\n   */\r\n  get buffer () {\r\n    let buffer = this._buffer\r\n\r\n    if (!buffer) {\r\n      if (this.version === 0) {\r\n        buffer = this.multihash\r\n      } else if (this.version === 1) {\r\n        buffer = Buffer.concat([\r\n          Buffer.from('01', 'hex'),\r\n          multicodec.getCodeVarint(this.codec),\r\n          this.multihash\r\n        ])\r\n      } else {\r\n        throw new Error('unsupported version')\r\n      }\r\n\r\n      // Cache this buffer so it doesn't have to be recreated\r\n      Object.defineProperty(this, '_buffer', { value: buffer })\r\n    }\r\n\r\n    return buffer\r\n  }\r\n\r\n  /**\r\n   * Get the prefix of the CID.\r\n   *\r\n   * @returns {Buffer}\r\n   * @readonly\r\n   */\r\n  get prefix () {\r\n    return Buffer.concat([\r\n      Buffer.from(`0${this.version}`, 'hex'),\r\n      multicodec.getCodeVarint(this.codec),\r\n      mh.prefix(this.multihash)\r\n    ])\r\n  }\r\n\r\n  /**\r\n   * Convert to a CID of version `0`.\r\n   *\r\n   * @returns {CID}\r\n   */\r\n  toV0 () {\r\n    if (this.codec !== 'dag-pb') {\r\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\r\n    }\r\n\r\n    const { name, length } = mh.decode(this.multihash)\r\n\r\n    if (name !== 'sha2-256') {\r\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\r\n    }\r\n\r\n    if (length !== 32) {\r\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\r\n    }\r\n\r\n    return new _CID(0, this.codec, this.multihash)\r\n  }\r\n\r\n  /**\r\n   * Convert to a CID of version `1`.\r\n   *\r\n   * @returns {CID}\r\n   */\r\n  toV1 () {\r\n    return new _CID(1, this.codec, this.multihash)\r\n  }\r\n\r\n  /**\r\n   * Encode the CID into a string.\r\n   *\r\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\r\n   * @returns {string}\r\n   */\r\n  toBaseEncodedString (base = this.multibaseName) {\r\n    if (this.string && base === this.multibaseName) {\r\n      return this.string\r\n    }\r\n    let str = null\r\n    if (this.version === 0) {\r\n      if (base !== 'base58btc') {\r\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\r\n      }\r\n      str = mh.toB58String(this.multihash)\r\n    } else if (this.version === 1) {\r\n      str = multibase.encode(base, this.buffer).toString()\r\n    } else {\r\n      throw new Error('unsupported version')\r\n    }\r\n    if (base === this.multibaseName) {\r\n      // cache the string value\r\n      Object.defineProperty(this, 'string', { value: str })\r\n    }\r\n    return str\r\n  }\r\n\r\n  /**\r\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\r\n   *\r\n   * @returns {String}\r\n   */\r\n  [Symbol.for('nodejs.util.inspect.custom')] () {\r\n    return 'CID(' + this.toString() + ')'\r\n  }\r\n\r\n  toString (base) {\r\n    return this.toBaseEncodedString(base)\r\n  }\r\n\r\n  /**\r\n   * Serialize to a plain object.\r\n   *\r\n   * @returns {SerializedCID}\r\n   */\r\n  toJSON () {\r\n    return {\r\n      codec: this.codec,\r\n      version: this.version,\r\n      hash: this.multihash\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compare equality with another CID.\r\n   *\r\n   * @param {CID} other\r\n   * @returns {bool}\r\n   */\r\n  equals (other) {\r\n    return this.codec === other.codec &&\r\n      this.version === other.version &&\r\n      this.multihash.equals(other.multihash)\r\n  }\r\n\r\n  /**\r\n   * Test if the given input is a valid CID object.\r\n   * Throws if it is not.\r\n   *\r\n   * @param {any} other\r\n   * @returns {void}\r\n   */\r\n  static validateCID (other) {\r\n    const errorMsg = CIDUtil.checkCIDComponents(other)\r\n    if (errorMsg) {\r\n      throw new Error(errorMsg)\r\n    }\r\n  }\r\n}\r\n\r\nconst _CID = withIs(CID, {\r\n  className: 'CID',\r\n  symbolName: '@ipld/js-cid/CID'\r\n})\r\n\r\n_CID.codecs = codecs\r\n\r\nmodule.exports = _CID\r\n"]},"metadata":{},"sourceType":"script"}