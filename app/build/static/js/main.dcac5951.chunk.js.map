{"version":3,"sources":["components/WhitePaper/WhitePaper.js","App.js","serviceWorker.js","index.js"],"names":["WhitePaper","web3","props","id","supply","for","name","onClick","e","preventDefault","alert","accounts","address","type","App","componentDidMount","a","Web3","givenProvider","eth","getAccounts","net","getId","networkId","deployedNetwork","ngmi","networks","ngmiInstance","Contract","abi","methods","call","setState","contract","totalSupply","runExample","console","error","mintToken","state","send","from","ngmiResponse","storageValue","bind","addressReceipt","this","faucetAddress","mint","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+5kGA2CeA,ICpCXC,EDoCWD,EAxCf,SAAqBE,GAQlB,OACQ,8BACP,sBAAKC,GAAK,cAAV,UACA,kDADA,IAC0B,iDAAoBD,EAAME,OAA1B,OAC1B,6nBAOA,+BACA,wFACA,6IACA,+LACA,yKACA,yJACA,mLAEA,kJACA,kJACA,kHACA,uBAAOC,IAAI,SAASF,GAAK,UAAzB,oDACC,wBAAQG,KAAO,SAASC,QA9BP,SAAAC,GACpBA,EAAEC,iBACFC,MAAM,mBAAqBR,EAAMS,SAAS,IAC1CT,EAAMU,QAAQV,EAAMS,SAAS,KA2BqBE,KAAK,SAApD,0B,kBCoCUC,E,kDA3Dd,WAAYZ,GAAO,IAAD,8BACjB,cAAMA,IAMPa,kBAPkB,sBAOE,oCAAAC,EAAA,sEAGjBf,EAAO,IAAIgB,IAAKA,IAAKC,eAAiB,uBAHrB,SAIMjB,EAAKkB,IAAIC,cAJf,cAIXT,EAJW,gBAOOV,EAAKkB,IAAIE,IAAIC,QAPpB,cAOXC,EAPW,OAQbC,EAAkBC,EAAKC,SAASH,GAC9BI,EAAe,IAAI1B,EAAKkB,IAAIS,SACnCH,EAAKI,IACLL,GAAmBA,EAAgBZ,SAXjB,UAaIe,EAAaG,QAAb,cAAuCC,OAb3C,QAaX3B,EAbW,OAcjB,EAAK4B,SAAS,CAAE/B,OAAMU,WAAUsB,SAAUN,EAAcO,YAAa9B,GAAS,EAAK+B,YAdlE,kDAiBjBzB,MAAM,0EAGN0B,QAAQC,MAAR,MApBiB,0DAPF,EA+BhBC,UA/BgB,uCA+BJ,WAAO1B,GAAP,uBAAAI,EAAA,+DACmB,EAAKuB,MAA5B5B,EADI,EACJA,SAAUsB,EADN,EACMA,SADN,SAGNA,EAASH,QAAT,WAAgCU,KAAK,CAAEC,KAAM9B,EAAS,KAHhD,uBAIesB,EAASH,QAAT,WAAgCC,OAJ/C,cAINW,EAJM,gBAKST,EAASH,QAAT,cAAmCC,OAL5C,OAKN3B,EALM,OAMZ,EAAK4B,SAAS,CAAEW,aAAcD,EAAcR,YAAa9B,IAN7C,4CA/BI,sDAEjB,EAAKmC,MAAQ,CAAEtC,KAAM,KAAMU,SAAU,KAAMsB,SAAU,KAAMC,YAAa,MACxE,EAAKI,UAAY,EAAKA,UAAUM,KAAf,gBACjB,EAAKC,eAAiB,EAAKA,eAAeD,KAApB,gBAJL,E,2DAwCDhC,GACfkC,KAAKR,UAAUQ,KAAKP,MAAMQ,iB,+BAIzB,OAAKD,KAAKP,MAAMtC,KAET,8BACP,cAAC,EAAD,CACA+C,KAAQF,KAAKR,UACb1B,QAAWkC,KAAKD,eAChBlC,SAAYmC,KAAKP,MAAM5B,SACvBP,OAAU0C,KAAKP,MAAML,gBAPQ,0D,GA9Cfe,IAAMC,W,OCEJC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.dcac5951.chunk.js","sourcesContent":["\r\nimport './WhitePaper.css';\r\n\r\nfunction WhitePaper (props){\r\n\tconst handleSubmit = e => {\r\n\t\te.preventDefault();\r\n\t\talert(\"Confirm address:\" + props.accounts[0]);\r\n\t\tprops.address(props.accounts[0]);\r\n  };\r\n\r\n\t\r\n\t  return (\r\n           <div>\r\n\t\t\t\t<div id = \"quick-intro\">\r\n\t\t\t\t<h1>Replatform Token</h1> <h3> Total minted: {props.supply} </h3>\r\n\t\t\t\t<p>Below is a faucet for Replatform Token (symbol: NGMI).\r\n\t\t\t\tIn the event that our favorite forums, boards, or communities in-general are shut-down,\r\n\t\t\t\thaving this token in your wallet will allow us to find each other. \r\n\t\t\t\tDue to recent events, I am releasing this faucet before the app is complete. \r\n\t\t\t\tJust copy/paste your address, and the faucet will mint a single token for you for free (exluding gas prices). \r\n\t\t\t\tI think there is enough time left for completion of the app without too much worry. But better safe than sorry...\r\n\t\t\t\tI will release a whitepaper when I get a chance, but the goals of the project are as follows:</p>\r\n\t\t\t\t<ol>\r\n\t\t\t\t<li>ERC721 that can be requested for specific communities.</li>\r\n\t\t\t\t<li>ERC721 creates owner for community ERC20 contract. Owner can then distribute ERC20 to respective community.</li>\r\n\t\t\t\t<li>Replatform Token will then ping requested forums and boards continuously, and an algorithm(most likely an oracle) will determine if that address still exists</li>\r\n\t\t\t\t<li>If the algorithm determines that the address no longer exists, it will fire up a new address with features similar to the 404'd address</li>\r\n\t\t\t\t<li>The faucet for that 404'd address token will pause all further minting so no one new may enter the community for a time</li>\r\n\t\t\t\t<li>For a period of time determined by a specific community, the only way onto the new platform will be to verify identity with Deplatformed Token</li>\r\n\t\t\t\t</ol>\r\n\t\t\t\t<p>Please note: the contract will only permit 1 token per wallet, so please dont waste your gas fees requesting more</p>\r\n\t\t\t\t<p>If you would like to donate to the project, send ether to this address 0x9A5963174dD8f36Db69b81E5E70C81bDFd9fcc74</p>\r\n\t\t\t\t<p>If you would like to help with the project, add me on github at trismegistus-root</p>\r\n\t\t\t\t<label for=\"faucet\" id = \"caption\">Connect your wallet and press submit: </label>\r\n\t\t\t\t\t<button name = \"faucet\" onClick={handleSubmit} type=\"submit\">\r\n\t\t\t\t\t  Submit\r\n\t\t\t\t\t</button>\r\n\t\t\t\t</div>\r\n\t\t   </div>\r\n          )\r\n\t\r\n}\r\n\r\nexport default WhitePaper;","import React from \"react\";\r\nimport ngmi from './contracts/ngmi.json';\r\nimport \"./App.css\";\r\nimport WhitePaper from \"./components/WhitePaper/WhitePaper.js\";\r\nimport Web3 from 'web3';\r\n\r\n\r\nlet web3;\r\n\r\n\r\nclass App extends React.Component{\r\n\tconstructor(props){\r\n\t\tsuper(props);\r\n\t\tthis.state = { web3: null, accounts: null, contract: null, totalSupply: null};\r\n\t\tthis.mintToken = this.mintToken.bind(this);\r\n\t\tthis.addressReceipt = this.addressReceipt.bind(this);\r\n\t}\r\n\r\n\tcomponentDidMount = async () => {\r\n\t\t\r\n\t\ttry {\r\n\t\t  web3 = new Web3(Web3.givenProvider || \"ws://localhost:8545\");  //set this.state({web3})\r\n\t\t  const accounts = await web3.eth.getAccounts();\t\t\t\t //set this.state({accounts})\r\n\r\n\t\t  // Get the contract instance.\r\n\t\t  const networkId = await web3.eth.net.getId();\t\t\t\t\t\r\n\t\t  let deployedNetwork = ngmi.networks[networkId];\r\n\t\t  const ngmiInstance = new web3.eth.Contract(\r\n\t\t\tngmi.abi,\r\n\t\t\tdeployedNetwork && deployedNetwork.address,\r\n\t\t  );\t\t\t\t\t\t\t\t\t\t\t\t\t\t     //set this.state({contract})\r\n\t\t  const supply = await ngmiInstance.methods.[\"totalSupply\"]().call();\r\n\t\t  this.setState({ web3, accounts, contract: ngmiInstance, totalSupply: supply}, this.runExample);\r\n\t\t} catch (error) {\r\n\t\t  // Catch any errors for any of the above operations.\r\n\t\t  alert(\r\n\t\t\t`Failed to load web3, accounts, or contract. Check console for details.`,\r\n\t\t  );\r\n\t\t  console.error(error);\r\n\t\t}\r\n\t  };\r\n\r\n\t\t mintToken = async (address) => {\r\n\t\t\tconst { accounts, contract } = this.state;\r\n\r\n\t\t\tawait contract.methods.[\"getToken\"]().send({ from: accounts[0]});\r\n\t\t\tconst ngmiResponse = await contract.methods.[\"getToken\"]().call();\r\n\t\t\tconst supply = await contract.methods.[\"totalSupply\"]().call();\r\n\t\t\tthis.setState({ storageValue: ngmiResponse, totalSupply: supply});\r\n\t\t\t};\r\n\r\n\t\t addressReceipt(address){\r\n\t\t\tthis.mintToken(this.state.faucetAddress);\r\n\t\t}\r\n\r\n\trender(){\r\n\t\t  if (!this.state.web3) return <div>Connect a wallet...</div>;\r\n          return (\r\n           <div>\r\n\t\t\t\t<WhitePaper \r\n\t\t\t\tmint = {this.mintToken} \r\n\t\t\t\taddress = {this.addressReceipt} \r\n\t\t\t\taccounts = {this.state.accounts} \r\n\t\t\t\tsupply = {this.state.totalSupply}\r\n\t\t\t\t/>\r\n\t\t   </div>\r\n          )\r\n       }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}